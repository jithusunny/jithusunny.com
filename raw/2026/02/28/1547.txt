One issue i noticed is:
when I click save note, I get the browser alert/popup saying "Changes that you made may not be saved.".
Ideally it should just have saved the thought based onthe path/filename we want and go back to home page.

Another change I want is, show only top 10 thoughts in home page, have next button at bottom.
Also prev when we go to the next page.

Let's add a new story, spec, task tracker based on this change.

Ideally I want the current spec, current story to be the only things we need if everything else is lost.

i.e., if I give the current spec alone to anybody else they should be able to just hand it to some Coding agent like
cursor and have the software ready soon.

But the problem there is that it is a bit inefficient to generate all code every single time.
I imagine, there may be only a couple of lines change between the codebase generated by two specs.
So we should also have a library of building blocks - something like the polylith architecture.

The building blocks can be reused across projects. Each building block can be like a capability
or subcapability - I don't have a clear sense of this. For example, should entire auth be a building block or just signin part a building block?
The considerations to identify/define building blocks would be:
- it is easy to reuse the block across diverse projects
- it is easy to pass any minimal configuration/input so that it can work as per the project specifics?
- it does not have any project specific stuff
- each building block will have an unambiguous definition and how to use

So when it is time to define the tasks at any point, the planner that defines the tasks should look at the story first to get the overall theme.
Then it must see the spec and the library of building blocks. And based on what is already available, it must define the tasks.
The library of building blocks can be outside projects folder - building_blocks - it can be called.
Inside it, let's have folders: python, html, js, css. And inside each, we will have one folder per building block.
Building blocks may have to be used together with other building blocks. 
For example a certain backend functionality may need a certain HTML block and a js block in the frontend.
Yet, there should not be any project specific stuff in the building blocks. Projects can be anything.

Let's not overdo this part - try and do as good as possible.

Once the planner is done with the tasks definition - again remember this tasks definition is complete - it does not append to the previous task definition.
It does not only say what more is needed, etc.

It is by itself the tasks that are needed to build the newly imagined complete software.

Once tasks are ready, the implementation is to be done.

This will have to be done in a peculiar way
